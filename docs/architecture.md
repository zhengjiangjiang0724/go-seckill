# 高并发秒杀系统架构设计文档

## 1. 系统概述

### 1.1 项目简介

本项目是一个基于Go语言开发的高并发秒杀系统，旨在解决电商场景下的高并发抢购问题。系统采用微服务架构思想，通过缓存、限流、分布式锁等技术手段，确保在高并发场景下的数据一致性和系统稳定性。

### 1.2 核心需求

- **高并发处理**: 支持10,000+ QPS的并发请求
- **数据一致性**: 确保商品库存不超卖
- **系统稳定性**: 在高负载下保持服务可用
- **用户体验**: 响应时间控制在200ms以内

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────┐
│  客户端层   │
│  (浏览器/App) │
└──────┬──────┘
       │ HTTP/HTTPS
       ▼
┌─────────────────────────────────────────┐
│            API网关层                     │
│  ┌───────────────────────────────────┐  │
│  │  Gin HTTP Server                  │  │
│  │  - 路由管理                        │  │
│  │  - 限流中间件                      │  │
│  │  - 认证授权                        │  │
│  └───────────────────────────────────┘  │
└──────┬───────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│           业务逻辑层                     │
│  ┌───────────────────────────────────┐  │
│  │  Controller 控制器层               │  │
│  │  - 请求参数验证                    │  │
│  │  - 响应格式化                      │  │
│  └───────────────────────────────────┘  │
│  ┌───────────────────────────────────┐  │
│  │  Service 服务层                    │  │
│  │  - 秒杀核心逻辑                    │  │
│  │  - 业务规则处理                    │  │
│  └───────────────────────────────────┘  │
└──────┬───────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│           数据访问层                     │
│  ┌──────────────┐  ┌──────────────┐    │
│  │    Redis     │  │    MySQL     │    │
│  │  缓存层      │  │  持久化层    │    │
│  │  - 库存缓存  │  │  - 商品信息  │    │
│  │  - 令牌缓存  │  │  - 订单数据  │    │
│  │  - 分布式锁  │  │              │    │
│  └──────────────┘  └──────────────┘    │
└─────────────────────────────────────────┘
```

### 2.2 分层架构

#### 2.2.1 表现层 (Controller)

- **职责**: 处理HTTP请求，参数验证，响应格式化
- **技术**: Gin Web框架
- **特点**: 轻量级、高性能、易扩展

#### 2.2.2 业务层 (Service)

- **职责**: 核心业务逻辑实现
- **功能**:
  - 秒杀令牌生成
  - 库存扣减
  - 订单创建
  - 业务规则校验

#### 2.2.3 数据层 (Model/Database/Cache)

- **职责**: 数据持久化和缓存管理
- **技术**:
  - MySQL: 关系型数据库，存储商品和订单
  - Redis: 缓存数据库，存储库存和令牌
  - GORM: ORM框架

### 2.3 核心组件

#### 2.3.1 缓存系统 (Redis)

**作用**:
- 库存缓存：秒杀商品库存预加载到Redis
- 令牌缓存：秒杀令牌临时存储
- 分布式锁：防止并发修改

**数据结构**:
```
seckill:stock:{product_id}     -> 库存数量 (String)
seckill:token:{token}          -> 令牌标识 (String, TTL: 1小时)
seckill:order:{user_id}:{product_id} -> 订单号 (String)
seckill:lock:{key}             -> 分布式锁 (String)
```

#### 2.3.2 数据库设计

**商品表 (products)**:
```sql
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    seckill_stock INT NOT NULL DEFAULT 0,
    start_time DATETIME NOT NULL,
    end_time DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    INDEX idx_start_time (start_time),
    INDEX idx_end_time (end_time)
);
```

**订单表 (orders)**:
```sql
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_no VARCHAR(64) UNIQUE NOT NULL,
    user_id VARCHAR(64) NOT NULL,
    product_id BIGINT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_product_id (product_id),
    INDEX idx_order_no (order_no),
    INDEX idx_status (status)
);
```

## 3. 核心流程设计

### 3.1 秒杀流程

```
1. 用户请求秒杀
   │
   ├─> [限流检查] 全局限流 + 用户限流
   │
   ├─> [生成令牌] 检查秒杀时间、库存
   │   │
   │   ├─> 检查秒杀时间是否有效
   │   ├─> 检查Redis库存是否充足
   │   └─> 生成并缓存令牌 (TTL: 1小时)
   │
   └─> [执行秒杀] 使用令牌下单
       │
       ├─> 验证令牌有效性
       ├─> [Lua脚本] 原子性扣减库存
       │   │
       │   ├─> 检查库存 > 0
       │   ├─> 扣减库存 (DECR)
       │   └─> 记录订单号到缓存
       │
       ├─> [分布式锁] 保护数据库写入
       │
       ├─> 创建订单到数据库
       │
       └─> 删除令牌
```

### 3.2 库存预热流程

```
1. 商品创建/更新
   │
   └─> 同步库存到Redis
       │
       └─> 设置: seckill:stock:{product_id} = stock
```

### 3.3 防超卖机制

1. **Redis原子操作**: 使用DECR命令原子性扣减库存
2. **Lua脚本**: 将检查库存和扣减库存打包成原子操作
3. **分布式锁**: 保护数据库订单创建的临界区
4. **库存预检**: 在生成令牌时先检查库存

## 4. 技术选型

### 4.1 编程语言

- **Go 1.21+**: 
  - 原生并发支持 (goroutine)
  - 优秀的性能
  - 简洁的语法

### 4.2 Web框架

- **Gin**: 
  - 高性能HTTP框架
  - 中间件支持
  - 路由组管理

### 4.3 数据库

- **MySQL 8.0+**: 
  - 关系型数据存储
  - ACID特性保证
  - 成熟稳定

### 4.4 缓存

- **Redis 8.0+**: 
  - 高性能内存数据库
  - 丰富的数据结构
  - Lua脚本支持
  - 原子操作

### 4.5 ORM框架

- **GORM**: 
  - Go语言ORM框架
  - 数据库迁移
  - 关联查询

## 5. 性能优化策略

### 5.1 缓存优化

1. **库存预热**: 秒杀开始前将库存加载到Redis
2. **缓存过期策略**: 令牌设置合理的TTL
3. **Pipeline批量操作**: 减少网络往返

### 5.2 数据库优化

1. **连接池**: 合理配置连接池大小
2. **索引优化**: 在查询字段上建立索引
3. **读写分离**: 读操作从从库，写操作在主库

### 5.3 代码优化

1. **协程池**: 控制并发数量
2. **减少序列化**: 使用高效的JSON库
3. **对象池**: 复用对象减少GC压力

### 5.4 限流策略

1. **全局限流**: 令牌桶算法，防止系统过载
2. **用户限流**: 防止单个用户过度请求
3. **接口限流**: 不同接口设置不同限流策略

## 6. 容错和降级

### 6.1 服务降级

- Redis故障时，降级到数据库查询（性能下降）
- 数据库故障时，返回错误提示

### 6.2 数据一致性

- 使用事务保证订单创建的原子性
- Redis和MySQL数据最终一致性

### 6.3 监控告警

- 监控QPS、响应时间、错误率
- 设置告警阈值，及时发现问题

## 7. 扩展性设计

### 7.1 水平扩展

- 无状态设计，支持多实例部署
- 使用负载均衡分发请求

### 7.2 数据库扩展

- 订单表按时间或用户ID分表
- 使用分库分表中间件

### 7.3 缓存扩展

- Redis集群模式
- 多级缓存架构

## 8. 安全性设计

### 8.1 接口安全

- Token验证机制
- 防止刷单：用户限流
- 防止脚本攻击：验证码、IP限流

### 8.2 数据安全

- SQL注入防护：使用参数化查询
- XSS防护：输入输出过滤
- 敏感信息加密

## 9. 部署架构

### 9.1 单机部署

```
┌─────────────────────────────┐
│   Go Seckill Service        │
│   (单实例)                   │
└───────┬─────────────────────┘
        │
        ├──> MySQL (本地/远程)
        └──> Redis (本地/远程)
```

### 9.2 集群部署

```
                ┌─────────────┐
                │  Load Balancer │
                └──────┬──────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
┌───────▼──────┐ ┌─────▼──────┐ ┌─────▼──────┐
│ Go Instance 1│ │Go Instance 2│ │Go Instance 3│
└───────┬──────┘ └─────┬──────┘ └─────┬──────┘
        │              │              │
        └──────────────┼──────────────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
┌───────▼──────┐ ┌─────▼──────┐ ┌─────▼──────┐
│   Redis      │ │   MySQL    │ │  MySQL     │
│  Cluster     │ │  Master    │ │  Slave     │
└──────────────┘ └────────────┘ └────────────┘
```

## 10. 总结

本系统通过合理的技术选型和架构设计，实现了高并发秒杀场景下的以下目标：

1. **高性能**: 通过Redis缓存和原子操作，支持高并发请求
2. **数据一致性**: 使用Lua脚本和分布式锁，确保不超卖
3. **系统稳定性**: 通过限流、降级等手段，保护系统不崩溃
4. **可扩展性**: 无状态设计，支持水平扩展

系统架构简洁明了，易于维护和扩展，适合中小型秒杀场景。

